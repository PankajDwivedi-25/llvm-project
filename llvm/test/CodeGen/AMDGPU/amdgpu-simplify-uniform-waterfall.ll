; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -mtriple=amdgcn-amd-amdhsa -mcpu=gfx1010 -O3 -S < %s | FileCheck %s --check-prefixes=PASS-CHECK

; Test case: Ensure that a loop with a divergent exit and a uniform value
; used by an intrinsic outside the loop is not optimized due to temporal divergence.

define amdgpu_kernel void @test_divergent_exit(ptr addrspace(1) %out, i32 %max_iter, i32 %div_cond) {
; PASS-CHECK-LABEL: define amdgpu_kernel void @test_divergent_exit(
; PASS-CHECK-SAME: ptr addrspace(1) nocapture writeonly [[OUT:%.*]], i32 [[MAX_ITER:%.*]], i32 [[DIV_COND:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
; PASS-CHECK-NEXT:  [[ENTRY:.*]]:
; PASS-CHECK-NEXT:    [[COND2:%.*]] = icmp eq i32 [[DIV_COND]], 0
; PASS-CHECK-NEXT:    br label %[[LOOP:.*]]
; PASS-CHECK:       [[LOOP]]:
; PASS-CHECK-NEXT:    [[ITER_VAL:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[NEW_ITER:%.*]], %[[LOOP]] ]
; PASS-CHECK-NEXT:    [[NEW_ITER]] = add i32 [[ITER_VAL]], 1
; PASS-CHECK-NEXT:    [[COND1:%.*]] = icmp sgt i32 [[NEW_ITER]], [[MAX_ITER]]
; PASS-CHECK-NEXT:    [[EXIT:%.*]] = or i1 [[COND2]], [[COND1]]
; PASS-CHECK-NEXT:    br i1 [[EXIT]], label %[[EXIT_BLOCK:.*]], label %[[LOOP]]
; PASS-CHECK:       [[EXIT_BLOCK]]:
; PASS-CHECK-NEXT:    store i32 [[NEW_ITER]], ptr addrspace(1) [[OUT]], align 4
; PASS-CHECK-NEXT:    ret void
;
entry:
  %iter = alloca i32, align 4
  store i32 0, ptr %iter, align 4
  br label %loop

loop:
  ; Increment loop counter
  %iter_val = load i32, ptr %iter, align 4
  %new_iter = add i32 %iter_val, 1
  store i32 %new_iter, ptr %iter, align 4

  ; Check exit conditions
  %cond1 = icmp sgt i32 %new_iter, %max_iter
  %cond2 = icmp eq i32 %div_cond, 0
  %exit = or i1 %cond1, %cond2
  br i1 %exit, label %exit_block, label %loop

exit_block:
  ; Use the uniform value in an intrinsic outside the loop
  %final_val = load i32, ptr %iter, align 4
  %result = call i32 @llvm.amdgcn.permlane64(i32 %final_val)
  store i32 %result, ptr addrspace(1) %out, align 4
  ret void
}

define protected amdgpu_kernel void @trivial_waterfall() local_unnamed_addr #0 {
; PASS-CHECK-LABEL: define protected amdgpu_kernel void @trivial_waterfall(
; PASS-CHECK-SAME: ) local_unnamed_addr #[[ATTR1:[0-9]+]] {
; PASS-CHECK-NEXT:  [[_PEEL_BEGIN:.*:]]
; PASS-CHECK-NEXT:    [[TMP5:%.*]] = tail call i32 asm sideeffect "", "=v,0"(i32 1) #[[ATTR5:[0-9]+]], !srcloc [[META0:![0-9]+]]
; PASS-CHECK-NEXT:    [[TMP6:%.*]] = icmp ne i32 [[TMP5]], 0
; PASS-CHECK-NEXT:    [[TMP7:%.*]] = tail call i32 @llvm.amdgcn.ballot.i32(i1 [[TMP6]])
; PASS-CHECK-NEXT:    [[TMP8:%.*]] = icmp eq i32 [[TMP7]], 0
; PASS-CHECK-NEXT:    br i1 [[TMP8]], [[DOTLOOPEXIT:label %.*]], [[DOTPEEL_NEWPH:label %.*]]
; PASS-CHECK:       [[_PEEL_NEWPH:.*:]]
; PASS-CHECK-NEXT:    [[TMP4:%.*]] = tail call i32 asm sideeffect "", "=v,0"(i32 0) #[[ATTR5]], !srcloc [[META0]]
; PASS-CHECK-NEXT:    [[TMP9:%.*]] = icmp ne i32 [[TMP4]], 0
; PASS-CHECK-NEXT:    [[TMP10:%.*]] = tail call i32 @llvm.amdgcn.ballot.i32(i1 [[TMP9]])
; PASS-CHECK-NEXT:    [[TMP11:%.*]] = icmp eq i32 [[TMP10]], 0
; PASS-CHECK-NEXT:    br i1 [[TMP11]], [[DOTLOOPEXIT]], [[DOTPEEL_NEWPH]], !llvm.loop [[LOOP1:![0-9]+]]
; PASS-CHECK:       [[_LOOPEXIT:.*:]]
; PASS-CHECK-NEXT:    ret void
;
  br label %1

1:                                                ; preds = %10, %0
  %2 = phi i8 [ 0, %0 ], [ %12, %10 ]
  %3 = and i8 %2, 1
  %4 = xor i8 %3, 1
  %5 = zext nneg i8 %4 to i32
  %6 = tail call i32 asm sideeffect "", "=v,0"(i32 %5) #2, !srcloc !6
  %7 = icmp ne i32 %6, 0
  %8 = tail call i64 @llvm.amdgcn.ballot.i64(i1 %7)
  %9 = icmp eq i64 %8, 0
  br i1 %9, label %13, label %10

10:                                               ; preds = %1
  %11 = icmp eq i8 %3, 0
  %12 = select i1 %11, i8 1, i8 %2
  br label %1, !llvm.loop !7

13:                                               ; preds = %1
  ret void
}

define protected amdgpu_kernel void @waterfall() local_unnamed_addr #0 {
; PASS-CHECK-LABEL: define protected amdgpu_kernel void @waterfall(
; PASS-CHECK-SAME: ) local_unnamed_addr #[[ATTR1]] {
; PASS-CHECK-NEXT:    [[TMP1:%.*]] = tail call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0)
; PASS-CHECK-NEXT:    br label %[[BB2:.*]]
; PASS-CHECK:       [[BB2]]:
; PASS-CHECK-NEXT:    [[TMP3:%.*]] = phi i1 [ false, [[TMP0:%.*]] ], [ [[DOTBE:%.*]], %[[DOTBACKEDGE:.*]] ]
; PASS-CHECK-NEXT:    [[TMP4:%.*]] = xor i1 [[TMP3]], true
; PASS-CHECK-NEXT:    [[TMP5:%.*]] = zext i1 [[TMP4]] to i32
; PASS-CHECK-NEXT:    [[TMP6:%.*]] = tail call i32 asm sideeffect "", "=v,0"(i32 [[TMP5]]) #[[ATTR5]], !srcloc [[META0]]
; PASS-CHECK-NEXT:    [[TMP7:%.*]] = icmp ne i32 [[TMP6]], 0
; PASS-CHECK-NEXT:    [[TMP8:%.*]] = tail call i32 @llvm.amdgcn.ballot.i32(i1 [[TMP7]])
; PASS-CHECK-NEXT:    [[TMP9:%.*]] = icmp eq i32 [[TMP8]], 0
; PASS-CHECK-NEXT:    br i1 [[TMP9]], label %[[BB14:.*]], label %[[BB10:.*]]
; PASS-CHECK:       [[BB10]]:
; PASS-CHECK-NEXT:    br i1 [[TMP3]], label %[[DOTBACKEDGE]], label %[[BB11:.*]]
; PASS-CHECK:       [[BB11]]:
; PASS-CHECK-NEXT:    [[TMP12:%.*]] = tail call noundef i32 @llvm.amdgcn.readfirstlane.i32(i32 [[TMP1]])
; PASS-CHECK-NEXT:    [[TMP13:%.*]] = icmp eq i32 [[TMP1]], [[TMP12]]
; PASS-CHECK-NEXT:    br label %[[DOTBACKEDGE]]
; PASS-CHECK:       [[_BACKEDGE:.*:]]
; PASS-CHECK-NEXT:    [[DOTBE]] = phi i1 [ true, %[[BB10]] ], [ [[TMP13]], %[[BB11]] ]
; PASS-CHECK-NEXT:    br label %[[BB2]], !llvm.loop [[LOOP4:![0-9]+]]
; PASS-CHECK:       [[BB14]]:
; PASS-CHECK-NEXT:    ret void
;
  %1 = tail call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0)
  %2 = tail call noundef i32 @llvm.amdgcn.mbcnt.hi(i32 -1, i32 %1)
  br label %3

3:                                                ; preds = %15, %0
  %4 = phi i1 [ false, %0 ], [ %16, %15 ]
  %5 = xor i1 %4, true
  %6 = zext i1 %5 to i32
  %7 = tail call i32 asm sideeffect "", "=v,0"(i32 %6) #3, !srcloc !6
  %8 = icmp ne i32 %7, 0
  %9 = tail call i64 @llvm.amdgcn.ballot.i64(i1 %8)
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %17, label %11

11:                                               ; preds = %3
  br i1 %4, label %15, label %12

12:                                               ; preds = %11
  %13 = tail call noundef i32 @llvm.amdgcn.readfirstlane.i32(i32 %2)
  %14 = icmp eq i32 %2, %13
  br label %15

15:                                               ; preds = %12, %11
  %16 = phi i1 [ true, %11 ], [ %14, %12 ]
  br label %3, !llvm.loop !7

17:                                               ; preds = %3
  ret void
}


declare i64 @llvm.amdgcn.ballot.i64(i1) #1
!6 = !{i64 690}
!7 = distinct !{!7, !8}
!8 = !{!"llvm.loop.mustprogress"}
;.
; PASS-CHECK: [[META0]] = !{i64 690}
; PASS-CHECK: [[LOOP1]] = distinct !{[[LOOP1]], [[META2:![0-9]+]], [[META3:![0-9]+]]}
; PASS-CHECK: [[META2]] = !{!"llvm.loop.mustprogress"}
; PASS-CHECK: [[META3]] = !{!"llvm.loop.peeled.count", i32 1}
; PASS-CHECK: [[LOOP4]] = distinct !{[[LOOP4]], [[META2]]}
;.
