; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -mtriple=amdgcn-amd-amdhsa -mcpu=gfx1010 -passes=amdgpu-uniform-intrinsic-combine -S < %s | FileCheck %s -check-prefix=PASS-CHECK
; RUN: opt -mtriple=amdgcn-amd-amdhsa -mcpu=gfx1010 -passes=amdgpu-uniform-intrinsic-combine,instcombine,early-cse,simplifycfg -S < %s | FileCheck %s -check-prefix=DCE-CHECK

define protected amdgpu_kernel void @trivial_waterfall(ptr addrspace(1) %out) {
; PASS-CHECK-LABEL: define protected amdgpu_kernel void @trivial_waterfall(
; PASS-CHECK-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0:[0-9]+]] {
; PASS-CHECK-NEXT:  [[ENTRY:.*]]:
; PASS-CHECK-NEXT:    br label %[[WHILE:.*]]
; PASS-CHECK:       [[WHILE]]:
; PASS-CHECK-NEXT:    [[DONE1:%.*]] = phi i1 [ false, %[[ENTRY]] ], [ true, %[[IF:.*]] ]
; PASS-CHECK-NEXT:    [[DONE:%.*]] = xor i1 [[DONE1]], true
; PASS-CHECK-NEXT:    [[BALLOT:%.*]] = tail call i64 @llvm.amdgcn.ballot.i64(i1 [[DONE]])
; PASS-CHECK-NEXT:    [[TMP0:%.*]] = zext i1 [[DONE]] to i64
; PASS-CHECK-NEXT:    [[IS_DONE:%.*]] = icmp eq i64 [[TMP0]], 0
; PASS-CHECK-NEXT:    br i1 [[IS_DONE]], label %[[EXIT:.*]], label %[[IF]]
; PASS-CHECK:       [[IF]]:
; PASS-CHECK-NEXT:    store i32 5, ptr addrspace(1) [[OUT]], align 4
; PASS-CHECK-NEXT:    br label %[[WHILE]]
; PASS-CHECK:       [[EXIT]]:
; PASS-CHECK-NEXT:    ret void
;
; DCE-CHECK-LABEL: define protected amdgpu_kernel void @trivial_waterfall(
; DCE-CHECK-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0:[0-9]+]] {
; DCE-CHECK-NEXT:  [[ENTRY:.*:]]
; DCE-CHECK-NEXT:    store i32 5, ptr addrspace(1) [[OUT]], align 4
; DCE-CHECK-NEXT:    ret void
;
entry:
  br label %while

while:
  %done = phi i1 [ 0, %entry ], [ 1, %if ]
  %not_done = xor i1 %done, true
  %ballot = tail call i64 @llvm.amdgcn.ballot.i64(i1 %not_done)
  %is_done = icmp eq i64 %ballot, 0
  br i1 %is_done, label %exit, label %if

if:
  store i32 5, ptr addrspace(1) %out
  br label %while

exit:
  ret void
}

define protected amdgpu_kernel void @waterfall(ptr addrspace(1) %out) {
; PASS-CHECK-LABEL: define protected amdgpu_kernel void @waterfall(
; PASS-CHECK-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; PASS-CHECK-NEXT:  [[ENTRY:.*]]:
; PASS-CHECK-NEXT:    [[TMP0:%.*]] = tail call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0)
; PASS-CHECK-NEXT:    [[TMP1:%.*]] = tail call noundef i32 @llvm.amdgcn.mbcnt.hi(i32 -1, i32 [[TMP0]])
; PASS-CHECK-NEXT:    br label %[[WHILE:.*]]
; PASS-CHECK:       [[WHILE]]:
; PASS-CHECK-NEXT:    [[TMP3:%.*]] = phi i1 [ false, %[[ENTRY]] ], [ [[NEW_DONE:%.*]], %[[TAIL:.*]] ]
; PASS-CHECK-NEXT:    [[TMP4:%.*]] = xor i1 [[TMP3]], true
; PASS-CHECK-NEXT:    [[TMP8:%.*]] = tail call i64 @llvm.amdgcn.ballot.i64(i1 [[TMP4]])
; PASS-CHECK-NEXT:    [[TMP9:%.*]] = icmp eq i64 [[TMP8]], 0
; PASS-CHECK-NEXT:    br i1 [[TMP9]], label %[[EXIT:.*]], label %[[IF:.*]]
; PASS-CHECK:       [[IF]]:
; PASS-CHECK-NEXT:    [[TMP12:%.*]] = tail call noundef i32 @llvm.amdgcn.readfirstlane.i32(i32 [[TMP1]])
; PASS-CHECK-NEXT:    [[TMP13:%.*]] = icmp eq i32 [[TMP1]], [[TMP12]]
; PASS-CHECK-NEXT:    br i1 [[TMP13]], label %[[WORK:.*]], label %[[TAIL]]
; PASS-CHECK:       [[WORK]]:
; PASS-CHECK-NEXT:    store i32 5, ptr addrspace(1) [[OUT]], align 4
; PASS-CHECK-NEXT:    br label %[[TAIL]]
; PASS-CHECK:       [[TAIL]]:
; PASS-CHECK-NEXT:    [[NEW_DONE]] = phi i1 [ true, %[[WORK]] ], [ false, %[[IF]] ]
; PASS-CHECK-NEXT:    br label %[[WHILE]]
; PASS-CHECK:       [[EXIT]]:
; PASS-CHECK-NEXT:    ret void
;
; DCE-CHECK-LABEL: define protected amdgpu_kernel void @waterfall(
; DCE-CHECK-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; DCE-CHECK-NEXT:  [[ENTRY:.*]]:
; DCE-CHECK-NEXT:    [[TMP0:%.*]] = tail call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0)
; DCE-CHECK-NEXT:    br label %[[WHILE:.*]]
; DCE-CHECK:       [[WHILE]]:
; DCE-CHECK-NEXT:    [[TMP2:%.*]] = phi i1 [ false, %[[ENTRY]] ], [ [[TMP12:%.*]], %[[TAIL:.*]] ]
; DCE-CHECK-NEXT:    [[TMP3:%.*]] = xor i1 [[TMP2]], true
; DCE-CHECK-NEXT:    [[TMP7:%.*]] = call i32 @llvm.amdgcn.ballot.i32(i1 [[TMP3]])
; DCE-CHECK-NEXT:    [[TMP8:%.*]] = icmp eq i32 [[TMP7]], 0
; DCE-CHECK-NEXT:    br i1 [[TMP8]], label %[[EXIT:.*]], label %[[IF:.*]]
; DCE-CHECK:       [[IF]]:
; DCE-CHECK-NEXT:    [[TMP11:%.*]] = tail call noundef i32 @llvm.amdgcn.readfirstlane.i32(i32 [[TMP0]])
; DCE-CHECK-NEXT:    [[TMP12]] = icmp eq i32 [[TMP0]], [[TMP11]]
; DCE-CHECK-NEXT:    br i1 [[TMP12]], label %[[WORK:.*]], label %[[TAIL]]
; DCE-CHECK:       [[WORK]]:
; DCE-CHECK-NEXT:    store i32 5, ptr addrspace(1) [[OUT]], align 4
; DCE-CHECK-NEXT:    br label %[[TAIL]]
; DCE-CHECK:       [[TAIL]]:
; DCE-CHECK-NEXT:    br label %[[WHILE]]
; DCE-CHECK:       [[EXIT]]:
; DCE-CHECK-NEXT:    ret void
;
entry:
  %1 = tail call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0)
  %tid = tail call noundef i32 @llvm.amdgcn.mbcnt.hi(i32 -1, i32 %1)
  br label %while

while:
  %done = phi i1 [ false, %entry ], [ %new_done, %tail ]
  %not_done = xor i1 %done, true
  %ballot = tail call i64 @llvm.amdgcn.ballot.i64(i1 %not_done)
  %is_done = icmp eq i64 %ballot, 0
  br i1 %is_done, label %exit, label %if

if:
  %first_active_id = tail call noundef i32 @llvm.amdgcn.readfirstlane.i32(i32 %tid)
  %is_first_active_id = icmp eq i32 %tid, %first_active_id
  br i1 %is_first_active_id, label %work, label %tail

work:
  store i32 5, ptr addrspace(1) %out
  br label %tail

tail:
  %new_done = phi i1 [ true, %work ], [ false, %if ]
  br label %while

exit:
  ret void
}

define protected amdgpu_kernel void @trivial_waterfall_multiple_icmp(ptr addrspace(1) %out) {
; PASS-CHECK-LABEL: define protected amdgpu_kernel void @trivial_waterfall_multiple_icmp(
; PASS-CHECK-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; PASS-CHECK-NEXT:  [[ENTRY:.*]]:
; PASS-CHECK-NEXT:    br label %[[WHILE:.*]]
; PASS-CHECK:       [[WHILE]]:
; PASS-CHECK-NEXT:    [[DONE:%.*]] = phi i1 [ false, %[[ENTRY]] ], [ true, %[[IF:.*]] ]
; PASS-CHECK-NEXT:    [[NOT_DONE:%.*]] = xor i1 [[DONE]], true
; PASS-CHECK-NEXT:    [[BALLOT:%.*]] = tail call i64 @llvm.amdgcn.ballot.i64(i1 [[NOT_DONE]])
; PASS-CHECK-NEXT:    [[TMP1:%.*]] = zext i1 [[NOT_DONE]] to i64
; PASS-CHECK-NEXT:    [[IS_DONE_1:%.*]] = icmp eq i64 [[TMP1]], 0
; PASS-CHECK-NEXT:    [[TMP0:%.*]] = zext i1 [[NOT_DONE]] to i64
; PASS-CHECK-NEXT:    [[IS_DONE_3:%.*]] = icmp eq i64 [[TMP0]], 0
; PASS-CHECK-NEXT:    br i1 [[IS_DONE_1]], label %[[EXIT:.*]], label %[[IF]]
; PASS-CHECK:       [[IF]]:
; PASS-CHECK-NEXT:    store i32 5, ptr addrspace(1) [[OUT]], align 4
; PASS-CHECK-NEXT:    [[TMP2:%.*]] = zext i1 [[NOT_DONE]] to i64
; PASS-CHECK-NEXT:    [[IS_DONE_4:%.*]] = icmp eq i64 [[TMP2]], 0
; PASS-CHECK-NEXT:    br label %[[WHILE]]
; PASS-CHECK:       [[EXIT]]:
; PASS-CHECK-NEXT:    ret void
;
; DCE-CHECK-LABEL: define protected amdgpu_kernel void @trivial_waterfall_multiple_icmp(
; DCE-CHECK-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; DCE-CHECK-NEXT:  [[ENTRY:.*:]]
; DCE-CHECK-NEXT:    store i32 5, ptr addrspace(1) [[OUT]], align 4
; DCE-CHECK-NEXT:    ret void
;
entry:
  br label %while

while:
  %done = phi i1 [ 0, %entry ], [ 1, %if ]
  %not_done = xor i1 %done, true
  %ballot = tail call i64 @llvm.amdgcn.ballot.i64(i1 %not_done)
  %is_done_1 = icmp eq i64 %ballot, 0
  %is_done_2 = icmp eq i64 %ballot, 0
  br i1 %is_done_1, label %exit, label %if

if:
  store i32 5, ptr addrspace(1) %out
  %is_done_3 = icmp eq i64 %ballot, 0
  br label %while

exit:
  ret void
}

declare i64 @llvm.amdgcn.ballot.i64(i1) #1
!6 = !{i64 690}
!7 = distinct !{!7, !8}
!8 = !{!"llvm.loop.mustprogress"}
