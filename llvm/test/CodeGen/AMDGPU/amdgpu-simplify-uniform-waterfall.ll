; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -mtriple=amdgcn-amd-amdhsa -mcpu=gfx1010 -passes=amdgpu-uniform-intrinsic-combine -S < %s | FileCheck %s -check-prefix=PASS-CHECK
; RUN: opt -mtriple=amdgcn-amd-amdhsa -mcpu=gfx1010 -passes=amdgpu-uniform-intrinsic-combine,early-cse,instcombine,simplifycfg -S < %s | FileCheck %s -check-prefix=DCE-CHECK

define protected amdgpu_kernel void @trivial_waterfall(ptr addrspace(1) %out) {
; PASS-CHECK-LABEL: define protected amdgpu_kernel void @trivial_waterfall(
; PASS-CHECK-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0:[0-9]+]] {
; PASS-CHECK-NEXT:  [[ENTRY:.*]]:
; PASS-CHECK-NEXT:    br label %[[WHILE:.*]]
; PASS-CHECK:       [[WHILE]]:
; PASS-CHECK-NEXT:    [[DONE:%.*]] = phi i1 [ false, %[[ENTRY]] ], [ true, %[[IF:.*]] ]
; PASS-CHECK-NEXT:    [[NOT_DONE:%.*]] = xor i1 [[DONE]], true
; PASS-CHECK-NEXT:    [[BALLOT:%.*]] = tail call i64 @llvm.amdgcn.ballot.i64(i1 [[NOT_DONE]])
; PASS-CHECK-NEXT:    [[TMP0:%.*]] = xor i1 [[NOT_DONE]], true
; PASS-CHECK-NEXT:    [[IS_DONE:%.*]] = icmp eq i64 [[BALLOT]], 0
; PASS-CHECK-NEXT:    br i1 [[TMP0]], label %[[EXIT:.*]], label %[[IF]]
; PASS-CHECK:       [[IF]]:
; PASS-CHECK-NEXT:    store i32 5, ptr addrspace(1) [[OUT]], align 4
; PASS-CHECK-NEXT:    br label %[[WHILE]]
; PASS-CHECK:       [[EXIT]]:
; PASS-CHECK-NEXT:    ret void
;
; DCE-CHECK-LABEL: define protected amdgpu_kernel void @trivial_waterfall(
; DCE-CHECK-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0:[0-9]+]] {
; DCE-CHECK-NEXT:  [[ENTRY:.*:]]
; DCE-CHECK-NEXT:    store i32 5, ptr addrspace(1) [[OUT]], align 4
; DCE-CHECK-NEXT:    ret void
;
entry:
  br label %while

while:
  %done = phi i1 [ 0, %entry ], [ 1, %if ]
  %not_done = xor i1 %done, true
  %ballot = tail call i64 @llvm.amdgcn.ballot.i64(i1 %not_done)
  %is_done = icmp eq i64 %ballot, 0
  br i1 %is_done, label %exit, label %if

if:
  store i32 5, ptr addrspace(1) %out
  br label %while

exit:
  ret void
}

define protected amdgpu_kernel void @waterfall(ptr addrspace(1) %out) {
; PASS-CHECK-LABEL: define protected amdgpu_kernel void @waterfall(
; PASS-CHECK-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; PASS-CHECK-NEXT:  [[ENTRY:.*]]:
; PASS-CHECK-NEXT:    [[TMP0:%.*]] = tail call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0)
; PASS-CHECK-NEXT:    [[TID:%.*]] = tail call noundef i32 @llvm.amdgcn.mbcnt.hi(i32 -1, i32 [[TMP0]])
; PASS-CHECK-NEXT:    br label %[[WHILE:.*]]
; PASS-CHECK:       [[WHILE]]:
; PASS-CHECK-NEXT:    [[DONE:%.*]] = phi i1 [ false, %[[ENTRY]] ], [ [[NEW_DONE:%.*]], %[[TAIL:.*]] ]
; PASS-CHECK-NEXT:    [[NOT_DONE:%.*]] = xor i1 [[DONE]], true
; PASS-CHECK-NEXT:    [[BALLOT:%.*]] = tail call i64 @llvm.amdgcn.ballot.i64(i1 [[NOT_DONE]])
; PASS-CHECK-NEXT:    [[IS_DONE:%.*]] = icmp eq i64 [[BALLOT]], 0
; PASS-CHECK-NEXT:    br i1 [[IS_DONE]], label %[[EXIT:.*]], label %[[IF:.*]]
; PASS-CHECK:       [[IF]]:
; PASS-CHECK-NEXT:    [[FIRST_ACTIVE_ID:%.*]] = tail call noundef i32 @llvm.amdgcn.readfirstlane.i32(i32 [[TID]])
; PASS-CHECK-NEXT:    [[IS_FIRST_ACTIVE_ID:%.*]] = icmp eq i32 [[TID]], [[FIRST_ACTIVE_ID]]
; PASS-CHECK-NEXT:    br i1 [[IS_FIRST_ACTIVE_ID]], label %[[WORK:.*]], label %[[TAIL]]
; PASS-CHECK:       [[WORK]]:
; PASS-CHECK-NEXT:    store i32 5, ptr addrspace(1) [[OUT]], align 4
; PASS-CHECK-NEXT:    br label %[[TAIL]]
; PASS-CHECK:       [[TAIL]]:
; PASS-CHECK-NEXT:    [[NEW_DONE]] = phi i1 [ true, %[[WORK]] ], [ false, %[[IF]] ]
; PASS-CHECK-NEXT:    br label %[[WHILE]]
; PASS-CHECK:       [[EXIT]]:
; PASS-CHECK-NEXT:    ret void
;
; DCE-CHECK-LABEL: define protected amdgpu_kernel void @waterfall(
; DCE-CHECK-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; DCE-CHECK-NEXT:  [[ENTRY:.*]]:
; DCE-CHECK-NEXT:    [[TMP0:%.*]] = tail call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0)
; DCE-CHECK-NEXT:    br label %[[WHILE:.*]]
; DCE-CHECK:       [[WHILE]]:
; DCE-CHECK-NEXT:    [[DONE:%.*]] = phi i1 [ false, %[[ENTRY]] ], [ [[IS_FIRST_ACTIVE_ID:%.*]], %[[TAIL:.*]] ]
; DCE-CHECK-NEXT:    [[NOT_DONE:%.*]] = xor i1 [[DONE]], true
; DCE-CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.amdgcn.ballot.i32(i1 [[NOT_DONE]])
; DCE-CHECK-NEXT:    [[IS_DONE:%.*]] = icmp eq i32 [[TMP1]], 0
; DCE-CHECK-NEXT:    br i1 [[IS_DONE]], label %[[EXIT:.*]], label %[[IF:.*]]
; DCE-CHECK:       [[IF]]:
; DCE-CHECK-NEXT:    [[FIRST_ACTIVE_ID:%.*]] = tail call noundef i32 @llvm.amdgcn.readfirstlane.i32(i32 [[TMP0]])
; DCE-CHECK-NEXT:    [[IS_FIRST_ACTIVE_ID]] = icmp eq i32 [[TMP0]], [[FIRST_ACTIVE_ID]]
; DCE-CHECK-NEXT:    br i1 [[IS_FIRST_ACTIVE_ID]], label %[[WORK:.*]], label %[[TAIL]]
; DCE-CHECK:       [[WORK]]:
; DCE-CHECK-NEXT:    store i32 5, ptr addrspace(1) [[OUT]], align 4
; DCE-CHECK-NEXT:    br label %[[TAIL]]
; DCE-CHECK:       [[TAIL]]:
; DCE-CHECK-NEXT:    br label %[[WHILE]]
; DCE-CHECK:       [[EXIT]]:
; DCE-CHECK-NEXT:    ret void
;
entry:
  %1 = tail call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0)
  %tid = tail call noundef i32 @llvm.amdgcn.mbcnt.hi(i32 -1, i32 %1)
  br label %while

while:
  %done = phi i1 [ false, %entry ], [ %new_done, %tail ]
  %not_done = xor i1 %done, true
  %ballot = tail call i64 @llvm.amdgcn.ballot.i64(i1 %not_done)
  %is_done = icmp eq i64 %ballot, 0
  br i1 %is_done, label %exit, label %if

if:
  %first_active_id = tail call noundef i32 @llvm.amdgcn.readfirstlane.i32(i32 %tid)
  %is_first_active_id = icmp eq i32 %tid, %first_active_id
  br i1 %is_first_active_id, label %work, label %tail

work:
  store i32 5, ptr addrspace(1) %out
  br label %tail

tail:
  %new_done = phi i1 [ true, %work ], [ false, %if ]
  br label %while

exit:
  ret void
}

define protected amdgpu_kernel void @trivial_waterfall_swap_op(ptr addrspace(1) %out) {
; PASS-CHECK-LABEL: define protected amdgpu_kernel void @trivial_waterfall_swap_op(
; PASS-CHECK-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; PASS-CHECK-NEXT:  [[ENTRY:.*]]:
; PASS-CHECK-NEXT:    br label %[[WHILE:.*]]
; PASS-CHECK:       [[WHILE]]:
; PASS-CHECK-NEXT:    [[DONE:%.*]] = phi i1 [ false, %[[ENTRY]] ], [ true, %[[IF:.*]] ]
; PASS-CHECK-NEXT:    [[NOT_DONE:%.*]] = xor i1 [[DONE]], true
; PASS-CHECK-NEXT:    [[BALLOT:%.*]] = tail call i64 @llvm.amdgcn.ballot.i64(i1 [[NOT_DONE]])
; PASS-CHECK-NEXT:    [[TMP0:%.*]] = xor i1 [[NOT_DONE]], true
; PASS-CHECK-NEXT:    [[IS_DONE:%.*]] = icmp eq i64 0, [[BALLOT]]
; PASS-CHECK-NEXT:    br i1 [[TMP0]], label %[[EXIT:.*]], label %[[IF]]
; PASS-CHECK:       [[IF]]:
; PASS-CHECK-NEXT:    store i32 5, ptr addrspace(1) [[OUT]], align 4
; PASS-CHECK-NEXT:    br label %[[WHILE]]
; PASS-CHECK:       [[EXIT]]:
; PASS-CHECK-NEXT:    ret void
;
; DCE-CHECK-LABEL: define protected amdgpu_kernel void @trivial_waterfall_swap_op(
; DCE-CHECK-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; DCE-CHECK-NEXT:  [[ENTRY:.*:]]
; DCE-CHECK-NEXT:    store i32 5, ptr addrspace(1) [[OUT]], align 4
; DCE-CHECK-NEXT:    ret void
;
entry:
  br label %while

while:
  %done = phi i1 [ 0, %entry ], [ 1, %if ]
  %not_done = xor i1 %done, true
  %ballot = tail call i64 @llvm.amdgcn.ballot.i64(i1 %not_done)
  %is_done = icmp eq i64 0, %ballot
  br i1 %is_done, label %exit, label %if

if:
  store i32 5, ptr addrspace(1) %out
  br label %while

exit:
  ret void
}

declare i64 @llvm.amdgcn.ballot.i64(i1) #1
!6 = !{i64 690}
!7 = distinct !{!7, !8}
!8 = !{!"llvm.loop.mustprogress"}
