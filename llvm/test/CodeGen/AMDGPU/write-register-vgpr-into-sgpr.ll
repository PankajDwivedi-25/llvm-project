; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=amdgcn -mcpu=bonaire -verify-machineinstrs -stop-after=finalize-isel | FileCheck %s -check-prefixes=GCN

; write_register doesn't prevent us from illegally trying to write a
; vgpr value into a scalar register, but I don't think there's much we
; can do to avoid this.

declare void @llvm.write_register.i32(metadata, i32) #0
declare i32 @llvm.amdgcn.workitem.id.x() #0
declare void @llvm.amdgcn.wave.barrier() #2

define amdgpu_kernel void @write_vgpr_into_sgpr() {
  ; GCN-LABEL: name: write_vgpr_into_sgpr
  ; GCN: bb.0 (%ir-block.0):
  ; GCN-NEXT:   liveins: $vgpr0
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   [[COPY:%[0-9]+]]:vgpr_32(s32) = COPY $vgpr0
  ; GCN-NEXT:   $exec_lo = V_READFIRSTLANE_B32 [[COPY]](s32), implicit $exec
  ; GCN-NEXT:   WAVE_BARRIER
  ; GCN-NEXT:   S_ENDPGM 0
  %tid = call i32 @llvm.amdgcn.workitem.id.x()
  call void @llvm.write_register.i32(metadata !0, i32 %tid)
  call void @llvm.amdgcn.wave.barrier() #2
  ret void
}

attributes #0 = { nounwind readnone }
attributes #1 = { nounwind }
attributes #2 = { convergent nounwind }

!0 = !{!"exec_lo"}
