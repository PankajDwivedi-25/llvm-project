; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=amdgcn-amd-amdhsa -mcpu=gfx90a -verify-machineinstrs -O0 -stop-after=finalize-isel | FileCheck %s -check-prefixes=GCN

; FIXME: This error will be fixed by supporting arbitrary divergent
; dynamic allocas by performing a wave umax of the size.


define i32 @move_to_valu_assert_srd_is_physreg_swdev503538(ptr addrspace(1) %ptr) {
  ; GCN-LABEL: name: move_to_valu_assert_srd_is_physreg_swdev503538
  ; GCN: bb.0.entry:
  ; GCN-NEXT:   successors: %bb.4(0x80000000)
  ; GCN-NEXT:   liveins: $vgpr0, $vgpr1
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   [[COPY:%[0-9]+]]:vgpr_32 = COPY $vgpr1
  ; GCN-NEXT:   [[COPY1:%[0-9]+]]:vgpr_32 = COPY $vgpr0
  ; GCN-NEXT:   [[DEF:%[0-9]+]]:sgpr_32 = IMPLICIT_DEF
  ; GCN-NEXT:   [[DEF1:%[0-9]+]]:sgpr_32 = IMPLICIT_DEF
  ; GCN-NEXT:   [[REG_SEQUENCE:%[0-9]+]]:vreg_64_align2 = REG_SEQUENCE [[COPY1]], %subreg.sub0, [[COPY]], %subreg.sub1
  ; GCN-NEXT:   [[DEF2:%[0-9]+]]:sreg_64 = IMPLICIT_DEF
  ; GCN-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def dead $scc, implicit-def $sgpr32, implicit $sgpr32
  ; GCN-NEXT:   [[COPY2:%[0-9]+]]:vgpr_32 = COPY $sgpr32
  ; GCN-NEXT:   $sgpr32 = V_READFIRSTLANE_B32 [[COPY2]], implicit $exec
  ; GCN-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def dead $scc, implicit-def $sgpr32, implicit $sgpr32
  ; GCN-NEXT:   [[COPY3:%[0-9]+]]:vgpr_32 = COPY [[COPY2]]
  ; GCN-NEXT:   [[DEF3:%[0-9]+]]:sreg_32 = IMPLICIT_DEF
  ; GCN-NEXT:   [[S_MOV_B64_:%[0-9]+]]:sreg_64_xexec = S_MOV_B64 $exec
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.4:
  ; GCN-NEXT:   successors: %bb.5(0x80000000)
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   [[V_READFIRSTLANE_B32_:%[0-9]+]]:sreg_32_xm0 = V_READFIRSTLANE_B32 [[COPY2]], implicit $exec
  ; GCN-NEXT:   [[V_CMP_EQ_U32_e64_:%[0-9]+]]:sreg_64_xexec = V_CMP_EQ_U32_e64 [[V_READFIRSTLANE_B32_]], [[COPY2]], implicit $exec
  ; GCN-NEXT:   [[S_AND_SAVEEXEC_B64_:%[0-9]+]]:sreg_64_xexec = S_AND_SAVEEXEC_B64 killed [[V_CMP_EQ_U32_e64_]], implicit-def $exec, implicit-def $scc, implicit $exec
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.5:
  ; GCN-NEXT:   successors: %bb.4(0x40000000), %bb.6(0x40000000)
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   [[BUFFER_LOAD_DWORD_OFFSET:%[0-9]+]]:vgpr_32 = BUFFER_LOAD_DWORD_OFFSET $sgpr0_sgpr1_sgpr2_sgpr3, killed [[V_READFIRSTLANE_B32_]], 0, 0, 0, implicit $exec :: (load (s32) from %ir.alloca, align 8, addrspace 5)
  ; GCN-NEXT:   $exec = S_XOR_B64_term $exec, [[S_AND_SAVEEXEC_B64_]], implicit-def $scc
  ; GCN-NEXT:   SI_WATERFALL_LOOP %bb.4, implicit $exec
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.6:
  ; GCN-NEXT:   successors: %bb.1(0x80000000)
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   $exec = S_MOV_B64 [[S_MOV_B64_]]
  ; GCN-NEXT:   [[S_MOV_B32_:%[0-9]+]]:sreg_32 = S_MOV_B32 0
  ; GCN-NEXT:   S_BRANCH %bb.1
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.1.loadstoreloop:
  ; GCN-NEXT:   successors: %bb.2(0x40000000), %bb.1(0x40000000)
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   [[PHI:%[0-9]+]]:sreg_32 = PHI [[S_MOV_B32_]], %bb.6, %3, %bb.1
  ; GCN-NEXT:   [[V_ADD_U32_e64_:%[0-9]+]]:vgpr_32 = V_ADD_U32_e64 [[COPY3]], [[PHI]], 0, implicit $exec
  ; GCN-NEXT:   [[V_MOV_B32_e32_:%[0-9]+]]:vgpr_32 = V_MOV_B32_e32 0, implicit $exec
  ; GCN-NEXT:   BUFFER_STORE_BYTE_OFFEN killed [[V_MOV_B32_e32_]], killed [[V_ADD_U32_e64_]], $sgpr0_sgpr1_sgpr2_sgpr3, 0, 0, 0, 0, implicit $exec :: (store (s8) into %ir.1, addrspace 5)
  ; GCN-NEXT:   [[S_MOV_B32_1:%[0-9]+]]:sreg_32 = S_MOV_B32 1
  ; GCN-NEXT:   [[S_ADD_I32_:%[0-9]+]]:sreg_32 = S_ADD_I32 [[PHI]], killed [[S_MOV_B32_1]], implicit-def dead $scc
  ; GCN-NEXT:   [[S_MOV_B32_2:%[0-9]+]]:sreg_32 = S_MOV_B32 2048
  ; GCN-NEXT:   S_CMP_LT_U32 [[S_ADD_I32_]], killed [[S_MOV_B32_2]], implicit-def $scc
  ; GCN-NEXT:   S_CBRANCH_SCC1 %bb.1, implicit $scc
  ; GCN-NEXT:   S_BRANCH %bb.2
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.2.Flow:
  ; GCN-NEXT:   successors: %bb.3(0x80000000)
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   S_BRANCH %bb.3
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.3.split:
  ; GCN-NEXT:   $vgpr0 = COPY [[BUFFER_LOAD_DWORD_OFFSET]]
  ; GCN-NEXT:   SI_RETURN implicit $vgpr0
entry:
  %idx = load i32, ptr addrspace(1) %ptr, align 4
  %zero = extractelement <4 x i32> zeroinitializer, i32 %idx
  %alloca = alloca [2048 x i8], i32 %zero, align 8, addrspace(5)
  %ld = load i32, ptr addrspace(5) %alloca, align 8
  call void @llvm.memset.p5.i32(ptr addrspace(5) %alloca, i8 0, i32 2048, i1 false)
  ret i32 %ld
}

declare void @llvm.memset.p5.i32(ptr addrspace(5) nocapture writeonly, i8, i32, i1 immarg) #0

attributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }
